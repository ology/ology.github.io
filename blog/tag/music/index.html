<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>techn.ology.net</title>
        <meta content="Statocles 0.097" name="generator">
        <link href="/blog/tag/music.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/tag/music.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">techn.ology.net</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">
                <div class="nine columns">
                    <main>
                        

<article>
    <header>
        <h1><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/">Generating Musical Phrases - Round II</a></h1>

        <aside>
            <time datetime="2020-11-23">
                Posted on 2020-11-23
            </time>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/music/" rel="tag">music</a>
            <a href="/blog/tag/software/" rel="tag">software</a>
            <a href="/blog/tag/perl/" rel="tag">perl</a>
            <a href="/blog/tag/midi/" rel="tag">MIDI</a>
            <a href="/blog/tag/generative/" rel="tag">generative</a>
        </p>

    </header>

    <p>It seems I am always fiddling with algorithmic musical composition.  Most recently it is with the program, polygenic, which is a descendant of the program in the previous post on this subject.</p>

<p>~</p>

<p>For this program, first up is to declare our standard Perl preamble.  Then version 5.20 is required (in order to allow <a href="https://perldoc.perl.org/perlref#Postfix-Dereference-Syntax">&quot;post-deref&quot; syntax</a>), and some of my favorite music modules - well many!</p>

<p>Anyway, next the program either gets or sets defaults for its parameters.  (The &quot;getting&quot; is done via the command-line as arguments given to the program.)  For instance, the default generated composition will be in the key of A minor at 105 beats per minute.</p>

<p>A <a href="https://metacpan.org/release/MIDI-Drummer-Tiny">drummer</a> is created.  This includes a handy score object.  The beat count is initialized at zero, the 3 parts are synchronized (i.e. played simultaneously), and the score is written to a MIDI file, which is set by the drummer and named after the program.</p>

<p>Pretty simple, eh?  Haha!  (Well yes, to me, the author, it is.)</p>

<p>The meat of this program lies in the two parts called &quot;top()&quot; and &quot;bottom()&quot; - Brilliant names, yes?  They are both extremely similar, but each have entirely different repeated phrases, and are in different octaves.</p>

<p>Please see the source code if you are interested in the workings.  But here are a couple audio examples.  Both are in 5/4 (drums and bass), but the top parts are in 4/4.  Why 5/4?  Because I am fascinated with odd meters and polyrhythms.</p>

<p>In the first, the top part is made with combinations of half, quarter and eighth notes.  The second adds triplet eighth notes to the mix.  I call this &quot;solo mode.&quot;  Haha.</p>

<p><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/polygenic-10-Solo-mode.mp3">polygenic-10-Solo-mode.mp3</a></p>

<p><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/polygenic-10-Solo-mode-1.mp3">polygenic-10-Solo-mode-1.mp3</a></p>

<p>Ok. One more.  This has phrases with &quot;charming grace-notes&quot;, because the phrase generator produced one without proper triplets:</p>

<p><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/polygenic-9-Charming-grace-notes.mp3">polygenic-9-Charming-grace-notes.mp3</a></p>

<p><strong>UPDATE:</strong></p>

<p>The <a href="https://github.com/ology/Music/blob/master/chordal">descendant program</a> that adds, what sound like chords:</p>

<p><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/chordal-03.mp3">chordal-03.mp3</a></p>

<p>Here is the same descendant program, but playing every other bar a whole note on top instead of the solo notes:</p>

<p><a href="/blog/2020/11/23/generating-musical-phrases-round-ii/chordal-04.mp3">chordal-04.mp3</a></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/11/11/generating-musical-phrases/">Generating Musical Phrases</a></h1>

        <aside>
            <time datetime="2020-11-11">
                Posted on 2020-11-11
            </time>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/music/" rel="tag">music</a>
            <a href="/blog/tag/software/" rel="tag">software</a>
            <a href="/blog/tag/perl/" rel="tag">perl</a>
            <a href="/blog/tag/midi/" rel="tag">MIDI</a>
            <a href="/blog/tag/generative/" rel="tag">generative</a>
        </p>

    </header>

    <p>After years of fiddling with algorithmic composition, I have come to reach for certain tools to craft melodies, bass-lines, solos, etc.  My latest generative composition program and output will illustrate...</p>

<p>~</p>

<p>The program in question is <a href="https://github.com/ology/Music/blob/master/quasi-random-durations">quasi-random-durations</a></p>

<p>The code libraries that I love to use so much are:</p>

<ul>
<li><a href="https://metacpan.org/release/Data-Dumper-Compact">Data::Dumper::Compact</a> - For concisely displaying the data structures that embody programmed musical things.</li>
<li><a href="https://metacpan.org/release/MIDI-Drummer-Tiny">MIDI::Drummer::Tiny</a> - For adding beats to my projects.</li>
<li><a href="https://metacpan.org/release/Music-Duration-Partition">Music::Duration::Partition</a> - For generating quasi-random rhythmic phrases in a given duration.</li>
<li><a href="https://metacpan.org/release/Music-Scales">Music::Scales</a> - For providing the scale notes that are the atoms of music.</li>
<li><a href="https://metacpan.org/release/Music-VoiceGen">Music::VoiceGen</a> - For generating a smooth series of pitches.</li>
</ul>

<p>(A couple are written by me, because they didn&#39;t exist yet!)</p>

<p>Here is the output of <a href="https://github.com/ology/Music/blob/master/quasi-random-durations">the program</a> imported into my <a href="https://www.apple.com/logic-pro/">DAW</a>, tweaked and enhanced.  The keyboards and bass were generated by selecting the &quot;better&quot; bits after many runs.  Also: it is an an odd time signature: 5/4, then 3/4, then 5/4 again.</p>

<p><a href="/blog/2020/11/11/generating-musical-phrases/Pentametric.mp3">Pentametric.mp3</a></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/11/01/imitating-a-drum-circle/">Imitating a Drum Circle</a></h1>

        <aside>
            <time datetime="2020-11-01">
                Posted on 2020-11-01
            </time>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/music/" rel="tag">music</a>
            <a href="/blog/tag/software/" rel="tag">software</a>
            <a href="/blog/tag/perl/" rel="tag">perl</a>
            <a href="/blog/tag/midi/" rel="tag">MIDI</a>
            <a href="/blog/tag/generative/" rel="tag">generative</a>
            <a href="/blog/tag/drums/" rel="tag">drums</a>
        </p>

    </header>

    <p><img align="left" src="/blog/2020/11/01/imitating-a-drum-circle/drum-circle.jpg">
Ever been to the park and heard a tribe drumming in the distance?  This is a <a href="https://en.wikipedia.org/wiki/Drum_circle">drum circle</a>.
Upon closer inspection, each drummer has a single instrument (or maybe a set of bongos).
Each drummer keeps a steady beat in common and in syncopation with his or her fellow drummers.</p>

<p>~</p>

<p>I wondered if this could be simulated somehow?  There are of course decisions to be made - parts to this equation... How should the drummers enter? All at once or gradually?  How should a drum be chosen or selected?  And what phrase(s) should be played anyway?</p>

<p>Enter MIDI-Perl.  Here is the program: <a href="https://github.com/ology/Music/blob/master/drum-circle">drum-circle</a></p>

<p>Basically it does the following:</p>

<ol>
<li><p>Use the modules necessary to have a drummer and rhythmic phrases.</p></li>
<li><p>Define the number of drummers ($max) as a number supplied by the user (or 4 by default).</p></li>
<li><p>Define a <a href="https://metacpan.org/pod/MIDI::Drummer::Tiny">MIDI::Drummer::Tiny</a> instance ($d), which will drive everything.</p></li>
<li><p>Set the possible drums to use (@DRUMS).  In our case this is a group of toms, bongos, congas, cabasa, maracas, guiro, claves, and wood blocks.</p></li>
<li><p>Declare an array of phrases (@phrases), which is to be populated with code-references.</p></li>
<li><p>Define a 4 bar <a href="https://metacpan.org/pod/Music::Duration::Partition">Music::Duration::Partition</a> instance ($mdp), which we will use to generate rhythmic motifs for each drummer.</p></li>
<li><p>Loop from 1 to $max, appending phrases to play for each new drummer.</p></li>
<li><p>Add the phrases to the score such that they are played simultaneously.</p></li>
<li><p>Write the generated &quot;composition&quot; to disk, as a MIDI file named after the program &quot;drum-circle.&quot;</p></li>
<li><p>Define the subroutine to generate our phrases!</p></li>
</ol>

<p>This last part is shown here:</p>

<pre><code>sub phrase {
    my ($p) = @_; # Phrase number

    # Get an unseen drum to use
    my $drum = $DRUMS[int rand @DRUMS];
    while ($seen{$drum}++) {
        $drum = $DRUMS[int rand @DRUMS];
    }

    # Create a rhythmic phrase
    my $motif = $mdp-&gt;motif;

    # Either rest or play the motif
    my $phrase = sub {
        for my $n (1 .. $d-&gt;bars + 4) {
            # If we are not up yet, then rest
            if ($n &lt; ($p * 4)) {
                $d-&gt;rest($d-&gt;whole);
                next;
            }
            # Otherwise play the rhythmic phrase!
            for my $i (@$motif) {
                # Get a fluctuating velocity between f and fff
                my $vol = &#39;v&#39; . (96 + int(rand 32));
                $d-&gt;note($i, $drum, $vol);
            }
        }
    };

    return $phrase;
}
</code></pre>

<p>Here the variable $p is the number 1 to $max from our loop in step #7 above.  Next, an unseen drum is selected at random.  Then a <em>quasi-random</em> rhythmic motif is generated by <a href="https://metacpan.org/pod/Music::Duration::Partition">Music::Duration::Partition</a> as defined above.  Finally an anonymous subroutine is returned, that just decides whether to play the generated motif or rest for a whole note.</p>

<p>This resting is crucial.  Each drummer enters after 16 bars of the previous drummer having played.  So, the second drummer enters after 4 bars, the third after 8, the fourth after 12, etc.  Having everyone play at once or at random was just not a pleasant musical evolution.  So I chose to have them enter one at a time.</p>

<p>Each run of this is different.  Sometimes you get a &quot;pleasant musical evolution&quot;, but sometimes you get all toms, or just a weird clash of rhythms.  Here is one with 8 voices that is ok:</p>

<p><a href="/blog/2020/11/01/imitating-a-drum-circle/drum-circle-8v.mp3">drum-circle-8v.mp3</a></p>

<p>And how about another?</p>

<p><a href="/blog/2020/11/01/imitating-a-drum-circle/drum-circle-8v-II.mp3">drum-circle-8v-II.mp3</a></p>

<p>Ok, one more!</p>

<p><a href="/blog/2020/11/01/imitating-a-drum-circle/drum-circle-8v-III.mp3">drum-circle-8v-III.mp3</a></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/10/18/imitating-steve-reich/">Imitating Steve Reich</a></h1>

        <aside>
            <time datetime="2020-10-18">
                Posted on 2020-10-18
            </time>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/music/" rel="tag">music</a>
            <a href="/blog/tag/software/" rel="tag">software</a>
            <a href="/blog/tag/perl/" rel="tag">perl</a>
            <a href="/blog/tag/midi/" rel="tag">MIDI</a>
            <a href="/blog/tag/generative/" rel="tag">generative</a>
        </p>

    </header>

    <p>Recently I was enjoying Steve Reich&#39;s <a href="https://www.youtube.com/watch?v=WgzQcDrX86M">&quot;Octet&quot; (Eight Lines)</a> and became curious if I could mimic the simple, staccato phrases with which he starts off his piece.</p>

<p>tl;dr: <a href="https://github.com/ology/Music/blob/master/reichify">reichify</a></p>

<p>~</p>

<p>Fortunately I have been immersed in algorithmic composition of late and had a fair idea what tools I would need.  Number one is <a href="https://www.perl.org/">Perl</a> and its vast ecosystem of modules - music ones in particular.  Let&#39;s go through the code!</p>

<pre><code>#!/usr/bin/env perl
use strict;
use warnings;

use Data::Dumper::Compact qw(ddc);
use List::Util qw(shuffle);
use lib map { &quot;$ENV{HOME}/sandbox/$_/lib&quot; } qw(MIDI-Praxis-Variation MIDI-Util Music-Interval-Barycentric);
use MIDI::Praxis::Variation qw(transposition);
use MIDI::Util;
use Music::Interval::Barycentric qw(cyclic_permutation);
use Music::Scales qw(get_scale_MIDI);
use Music::VoiceGen;
</code></pre>

<p>Here the standard perl preamble starts things off, followed by a handful of modules with methods and functions to use below.  Next up is to define a few crucial parameters (that can be provided on the command-line):</p>

<pre><code>my $bars   = shift || 32;
my $bpm    = shift || 180;
my $note   = shift || &#39;B&#39;;
my $scale  = shift || &#39;major&#39;;
</code></pre>

<p>Except for the number of bars, these are based on Reich&#39;s piece.</p>

<p>So this program uses global variables throughout.  This is not a recommended practice for mission-critical, production software!  Anyway, one of these globals is a voice generator created from the excellent <a href="https://metacpan.org/pod/Music::VoiceGen">Music::VoiceGen</a> module:</p>

<pre><code># Create a voice generator
my $octave = 2;
my @pitches = (
    get_scale_MIDI($note, $octave, $scale),
    get_scale_MIDI($note, $octave + 1, $scale),
    get_scale_MIDI($note, $octave + 2, $scale),
);
my $voice = Music::VoiceGen-&gt;new(
    pitches   =&gt; \@pitches,
    intervals =&gt; [qw(-4 -3 -2 -1 1 2 3 4)],
);
</code></pre>

<p>This allows a random pitch to be generated based on three octaves and the given legal interval jumps.  Next, a shuffled clarinet motif is defined and a clarinet note array declared:</p>

<pre><code># Clarinet track globals
my $cmotif = [shuffle qw(dhn en en en en)];
my @cnotes;
</code></pre>

<p>These will be used below, in the clarinet phrase generators...  Next the notes for the piano tracks are generated with this code:</p>

<pre><code># Generate notes for the piano tracks
my $pmotif = [(&#39;en&#39;) x 10];
my @pnotes;
my @transp;
for my $n (0 .. $#$pmotif) {
    my $note = note_or_rest($n, $pmotif, \@pnotes);
    push @pnotes, $note;
    if ($note eq &#39;r&#39;) {
        push @transp, &#39;r&#39;;
    }
    else {
        my @transposed = transposition(-12, $note);
        push @transp, $transposed[0];
    }
}
</code></pre>

<p>Here the piano motif is defined as ten eighth notes.  Notes are added to the <code>@pnotes</code> and <code>@transp</code> arrays in a loop over the <code>$pmotif</code> and the function <code>note_or_rest()</code> is called.  This function returns - you guessed it - either a note (as a MIDI pitch number) or a rest (as an &#39;r&#39; character).  This note is added to the <code>@pnotes</code> array, and a transposed version is added to the <code>@transp</code> array.</p>

<p>Ok. With all those things defined and populated, the next thing is to setup the MIDI stuff:</p>

<pre><code># Prepare the MIDI
my $volume = 98;
my $pan = 10; # control change #
my $pan_left = 32;
my $pan_right = 86;
my $score = MIDI::Util::setup_score(
    lead_in   =&gt; 0,
    signature =&gt; &#39;5/4&#39;,
    bpm       =&gt; $bpm,
    volume    =&gt; $volume,
);
</code></pre>

<p>And synchronize the piano, violin and clarinet parts to play:</p>

<pre><code># Add each part to the score in parallel
$score-&gt;synch(
    \&amp;piano1,
    \&amp;piano2,
    \&amp;violin1,
    \&amp;violin2,
    \&amp;clarinet1,
    \&amp;clarinet2,
);
</code></pre>

<p>Finally, as far as the execution of the program goes, a MIDI file, named after the program, is written to disk:</p>

<pre><code># Output the score as a MIDI file
$score-&gt;write_score(&quot;$0.mid&quot;);
</code></pre>

<p>Now for the subroutines!  Let&#39;s consider the first one we encountered above, <code>note_or_rest()</code>:</p>

<pre><code># Either return a note or a rest!
sub note_or_rest {
    my ($n, $motif, $notes) = @_;
    if (
        # We&#39;re at the end of the motif and the first note is a rest
        ($n == $#$motif &amp;&amp; $notes-&gt;[0] eq &#39;r&#39;)
        ||
        # The previous note is a rest
        (defined $notes-&gt;[$n - 1] &amp;&amp; $notes-&gt;[$n - 1] eq &#39;r&#39;)
    ) {
        $note = $voice-&gt;rand;
    }
    else {
        $note = int(rand 10) &lt;= 3 ? &#39;r&#39; : $voice-&gt;rand;
    }
    return $note;
}
</code></pre>

<p>Here, a note is generated so that two rests are not in a row.  That is what the if condition says basically.  Otherwise either a rest or a note is generated based on a probability (i.e. return a rest approximately 40% of the time).</p>

<p>The companion to this function is the following, which actually adds either a rest or notes to the score:</p>

<pre><code># Either play a note or a rest!
sub play_note_or_rest {
    my ($motif, $notes) = @_;
    if ($notes-&gt;[0] eq &#39;r&#39;) {
        $score-&gt;r($motif);
    }
    else {
        $score-&gt;n($motif, @$notes);
    }
}
</code></pre>

<p>In the generation of piano notes, if the first is a rest, so is the second.  That is why this code only considers the first element.</p>

<p>All that remains are the subroutines that play the pianos, violins and clarinets - which makes up the majority of the program actually.  The first piano looks like this:</p>

<pre><code># Play the pre-computed piano notes
sub piano1 {
    MIDI::Util::set_chan_patch($score, 0, 0);
    $score-&gt;control_change(0, $pan, $pan_left);
    print &#39;Piano 1.1: &#39;, ddc(\@pnotes);
    print &#39;Piano 1.2: &#39;, ddc(\@transp);
    for my $i (1 .. $bars) {
        for my $n (0 .. $#$pmotif) {
            play_note_or_rest($pmotif-&gt;[$n], [$pnotes[$n], $transp[$n]]);
        }
    }
}
</code></pre>

<p>Here, the MIDI channel and patch are both set to zero.  Then the pan is set to the defined left value.  The actual notes are shown (with the <code>ddc()</code> function of the also excellent <a href="https://metacpan.org/pod/Data::Dumper::Compact">Data::Dumper::Compact</a> module).  Next the computed notes (or rests) are added to the score in a loop over the defined number of <code>$bars</code>.  For each bar, a note or rest is played for each MIDI duration element of the motif.  <em>Voilà!</em></p>

<p>The other subroutines defining the other instruments are each different.  This is so that the composition is not stale and redundant.  But they are left to the reader to explore in <a href="https://github.com/ology/Music/blob/master/reichify">the program</a>.</p>

<p>Here is a composition based on three runs of very very many that I finally sort-of liked: <a href="/blog/2020/10/18/imitating-steve-reich/Reichifed-IV.mp3">Reichified II</a></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/06/06/musical-ngrams-round-ii/">Musical Ngrams Round II</a></h1>

        <aside>
            <time datetime="2020-06-06">
                Posted on 2020-06-06
            </time>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/music/" rel="tag">music</a>
            <a href="/blog/tag/software/" rel="tag">software</a>
            <a href="/blog/tag/perl/" rel="tag">perl</a>
            <a href="/blog/tag/midi/" rel="tag">MIDI</a>
            <a href="/blog/tag/analysis/" rel="tag">analysis</a>
            <a href="/blog/tag/ngrams/" rel="tag">ngrams</a>
        </p>

    </header>

    <p><img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/twinkle_ngram-play-durations.png">
What are &quot;ngrams&quot;?  And how do they relate to music?  Well <a href="https://en.wikipedia.org/wiki/N-gram">ngrams</a> are basically groups of tokens.  These groups are of a certain given size - say phrases of three words.  If we consider notes as tokens we get musical ngrams!  We can count the number of occurrences of each ngram phrase, and thus know how many times a given phrase is repeated.  How often does Bach repeat himself, for instance?</p>

<p>~</p>

<p>This is a short story about refactoring and new results.</p>

<p>After revisiting my <a href="https://metacpan.org/release/MIDI-Ngram">MIDI::Ngram</a> analysis module, I found that it was deeply broken with respect to multiples of things: channels, note durations and simultaneous events.  Naturally I had to fix it!</p>

<p>First I discovered that only MIDI channel 0 was being considered.  Shocking!  I fixed that by refactoring the basic hash data-structure used to parse things, by just making it save to the channel being considered.  Voila.  Now the analysis of repetitions shows whatever channel you want to inspect.</p>

<p>With this improved data-structure in hand, I focused my attention on tallying note durations.  That is, the time (in MIDI &quot;ticks&quot; not milliseconds) taken by each note, in the context of the tempo.   Now the analysis can show note duration repetition too.  Whew!</p>

<p>Okay.  So the whole point of this module is to expose the number of times a musical phrase is repeated - not just note pitches alone and not just durations either - but both.</p>

<p>For this I added pitch and duration events by start-time to the event data-structure, as mentioned above.  I process each with transliteration.  By this I mean that, in order to use the module <a href="https://metacpan.org/release/Lingua-EN-Ngram">Lingua::EN::Ngram</a> you need to encode the numerical note values.  I pass this transliterated string through Lingua::EN::Ngram to get the number of repeated phrases.  Now this module is made to ignore digits and punctuation.  But that is exactly what my constructed music strings are made of.  So by &quot;transliterate&quot; I mean apply this code to the music strings:</p>

<pre><code>tr/0-9,*|/a-m/
</code></pre>

<p>You get out unpronounceable groups of alphabetical strings, but they can now be analyzed by Lingua::EN::Ngram.  To return to music strings, we just reverse this transliteration.  <em>Voila!</em></p>

<p>Okay!  After fixing things, next up was to generate transition network graphs of note pitches, duration and the combination of the two.  This just involved looping over each event in order of start-time, and gathering the number of events to consider (the &quot;nodes&quot; of the graph).  This I chose to divide by the hyphen (&quot;dash&quot;) character.</p>

<p>So here are the results of analyzing ngrams of size 2, with a minimum of 2 occurrences in the <a href="https://fastapi.metacpan.org/source/GENE/MIDI-Ngram-0.1804/eg/twinkle_twinkle.mid">&quot;Twinkle Twinkle Little Star&quot;</a> MIDI file included with the distribution:</p>

<pre><code>$ perl eg/ngram-play --files eg/twinkle_twinkle.mid --size 2 --min 2 --out &#39;&#39;

Durations: {
    &#39;0&#39; =&gt; { &#39;hn qn&#39; =&gt; 5, &#39;qn hn&#39; =&gt; 6, &#39;qn qn&#39; =&gt; 30 },
    &#39;1&#39; =&gt; { &#39;hn hn&#39; =&gt; 18, &#39;hn qn&#39; =&gt; 2, &#39;qn hn&#39; =&gt; 2, &#39;qn qn&#39; =&gt; 4 }, }
}

Duration network: {
    &#39;0&#39; =&gt; {
        &#39;hn qn-qn qn&#39; =&gt; 3,
        &#39;qn hn-qn qn&#39; =&gt; 2,
        &#39;qn qn-hn qn&#39; =&gt; 3,
        &#39;qn qn-qn hn&#39; =&gt; 2,
        &#39;qn qn-qn qn&#39; =&gt; 9,
    },
    &#39;1&#39; =&gt; { &#39;hn hn-hn hn&#39; =&gt; 8, &#39;hn hn-qn qn&#39; =&gt; 2 },
}

Notes: {
    &#39;0&#39; =&gt; {
        &#39;A4 A4&#39; =&gt; 2,
        &#39;A4 G4&#39; =&gt; 2,
        &#39;C4 C4&#39; =&gt; 2,
        &#39;C4 G4&#39; =&gt; 3,
        &#39;D4 C4&#39; =&gt; 3,
        &#39;D4 D4&#39; =&gt; 2,
        &#39;E4 D4&#39; =&gt; 4,
        &#39;E4 E4&#39; =&gt; 4,
        &#39;F4 E4&#39; =&gt; 4,
        &#39;F4 F4&#39; =&gt; 4,
        &#39;G4 A4&#39; =&gt; 2,
        &#39;G4 F4&#39; =&gt; 4,
        &#39;G4 G4&#39; =&gt; 4,
    },
    &#39;1&#39; =&gt; {
        &#39;C3 E3&#39; =&gt; 3,
        &#39;C3 F3&#39; =&gt; 2,
        &#39;D3 C3&#39; =&gt; 2,
        &#39;E3 D3&#39; =&gt; 2,
        &#39;E3 F3&#39; =&gt; 4,
        &#39;F3 E3&#39; =&gt; 2,
        &#39;F3 G3&#39; =&gt; 4,
        &#39;G3 C3&#39; =&gt; 2,
        &#39;G3 E3&#39; =&gt; 2,
        &#39;G3 G3&#39; =&gt; 2,
    }
}

Note network: {
    &#39;0&#39; =&gt; {
        &#39;A4 A4-G4 F4&#39; =&gt; 2,
        &#39;C4 C4-G4 G4&#39; =&gt; 2,
        &#39;F4 E4-E4 D4&#39; =&gt; 3,
        &#39;G4 F4-F4 E4&#39; =&gt; 3,
        &#39;G4 G4-A4 A4&#39; =&gt; 2,
    },
    &#39;1&#39; =&gt; {
        &#39;C3 E3-F3 E3&#39; =&gt; 2,
        &#39;D3 C3-F3 G3&#39; =&gt; 2,
        &#39;E3 F3-G3 G3&#39; =&gt; 2,
        &#39;F3 E3-D3 C3&#39; =&gt; 2,
    }
}

Durations*Notes: {
    &#39;0&#39; =&gt; {
        &#39;hn*G4 qn*F4&#39; =&gt; 2,
        &#39;qn*A4 hn*G4&#39; =&gt; 2,
        &#39;qn*A4 qn*A4&#39; =&gt; 2,
        &#39;qn*C4 qn*C4&#39; =&gt; 2,
        &#39;qn*C4 qn*G4&#39; =&gt; 2,
        &#39;qn*D4 hn*C4&#39; =&gt; 2,
        &#39;qn*D4 qn*D4&#39; =&gt; 2,
        &#39;qn*E4 hn*D4&#39; =&gt; 2,
        &#39;qn*E4 qn*D4&#39; =&gt; 2,
        &#39;qn*E4 qn*E4&#39; =&gt; 4,
        &#39;qn*F4 qn*E4&#39; =&gt; 4,
        &#39;qn*F4 qn*F4&#39; =&gt; 4,
        &#39;qn*G4 qn*A4&#39; =&gt; 2,
        &#39;qn*G4 qn*F4&#39; =&gt; 2,
        &#39;qn*G4 qn*G4&#39; =&gt; 4,
    },
    &#39;1&#39; =&gt; {
        &#39;hn*C3 hn*E3&#39; =&gt; 2,
        &#39;hn*C3 qn*F3&#39; =&gt; 2,
        &#39;hn*D3 hn*C3&#39; =&gt; 2,
        &#39;hn*E3 hn*D3&#39; =&gt; 2,
        &#39;hn*E3 hn*F3&#39; =&gt; 4,
        &#39;hn*F3 hn*E3&#39; =&gt; 2,
        &#39;hn*F3 hn*G3&#39; =&gt; 2,
        &#39;hn*G3 hn*G3&#39; =&gt; 2,
        &#39;qn*F3 qn*G3&#39; =&gt; 2,
    }
}

Duration*Note network: {
    &#39;0&#39; =&gt; {
        &#39;hn*G4 qn*F4-qn*F4 qn*E4&#39; =&gt; 2,
        &#39;qn*A4 qn*A4-hn*G4 qn*F4&#39; =&gt; 2,
        &#39;qn*C4 qn*C4-qn*G4 qn*G4&#39; =&gt; 2,
        &#39;qn*F4 qn*E4-qn*E4 qn*D4&#39; =&gt; 2,
        &#39;qn*G4 qn*G4-qn*A4 qn*A4&#39; =&gt; 2,
    },
    &#39;1&#39; =&gt; {
        &#39;hn*C3 hn*E3-hn*F3 hn*E3&#39; =&gt; 2,
        &#39;hn*D3 hn*C3-qn*F3 qn*G3&#39; =&gt; 2,
        &#39;hn*E3 hn*F3-hn*G3 hn*G3&#39; =&gt; 2,
        &#39;hn*F3 hn*E3-hn*D3 hn*C3&#39; =&gt; 2,
    }
}
</code></pre>

<p>And here are the graphs generated by this command:</p>

<pre><code>$ perl eg/ngram-play --files eg/twinkle_twinkle.mid --size 2 --min 1 --out &#39;&#39; --image --chan 0
</code></pre>

<p>(Notice that the --min option is set to 1 this time.  This means consider all ngrams that repeat at least once.  Also --chan is 0 - the treble clef in this case.)</p>

<p><img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/twinkle_ngram-play-durations.png">
<img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/twinkle_ngram-play-notes.png">
<img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/twinkle_ngram-play-duration_note.png"></p>

<p>Here is the bass clef:</p>

<p><img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/Twinkle-1_ngram-analyze-durations.png">
<img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/Twinkle-1_ngram-analyze-notes.png">
<img alt="" src="/blog/2020/06/06/musical-ngrams-round-ii/Twinkle-1_ngram-analyze-duration_notes.png"></p>



</article>

<ul class="pager">
    <li class="prev">
            <button disabled>
                ← Older
            </button>
    </li>
    <li class="next">
            <button disabled>
                Newer →
            </button>
    </li>
</ul>




                    </main>
                </div>

                <div class="three columns sidebar">
                    
                        <nav id="tags">
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/analysis/">analysis</a></li>
            <li><a href="/blog/tag/drums/">drums</a></li>
            <li><a href="/blog/tag/generative/">generative</a></li>
            <li><a href="/blog/tag/midi/">MIDI</a></li>
            <li><a href="/blog/tag/music/">music</a></li>
            <li><a href="/blog/tag/ngrams/">ngrams</a></li>
            <li><a href="/blog/tag/perl/">perl</a></li>
            <li><a href="/blog/tag/software/">software</a></li>
        </ul>
    </nav>

                            <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/tag/music.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/tag/music.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>

                </div>
            </div>
        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>


    </body>
</html>
